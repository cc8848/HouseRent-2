<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_45) on Thu Nov 06 08:52:43 UTC 2014 -->
<TITLE>
DataTools (SmartClient v9.1p_2014-11-06/Pro Deployment)
</TITLE>

<META NAME="date" CONTENT="2014-11-06">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="DataTools (SmartClient v9.1p_2014-11-06/Pro Deployment)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../com/isomorphic/util/ErrorMessage.html" title="class in com.isomorphic.util"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/isomorphic/util/DataTools.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="DataTools.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.isomorphic.util</FONT>
<BR>
Class DataTools</H2>
<PRE>
<B>com.isomorphic.util.DataTools</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>DataTools</B></DL>
</PRE>

<P>
<code>DataTools</code> is a utility class with the following facilities:
 <ul>
 <li><code>getProperties()</code> and <code>setProperties()</code>: <code>getProperties()</code>
 allow the properties of any Java object to be extracted as a Map, and <code>setProperties</code>
 allows any Map to be applied to a Java object, calling setter methods named after the keys of the
 Map.  These methods are very useful for going from Java beans to a JavaScript representation and
 back.
 <li>prettyPrint(), which uses a JSTranslater to output a text summary of arbitrary Java objects,
 very useful for logging
 <li>many utilities for manipulating Java Collections
 </ul>
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/isomorphic/util/DataTools.html#prettyPrint(java.lang.Object)"><CODE>DataTools.prettyPrint(Object)</CODE></A>, 
<A HREF="../../../com/isomorphic/util/DataTools.html#getProperties(java.lang.Object)"><CODE>DataTools.getProperties(Object)</CODE></A>, 
<A HREF="../../../com/isomorphic/util/DataTools.html#setProperties(java.util.Map, java.lang.Object)"><CODE>DataTools.setProperties(Map, Object)</CODE></A></DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#addAll(java.util.List, java.util.Iterator)">addAll</A></B>(java.util.List&nbsp;target,
       java.util.Iterator&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds all the elements of an <code>Iterator</code> to a <code>List</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#addAll(java.util.List, java.util.List)">addAll</A></B>(java.util.List&nbsp;target,
       java.util.List&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the contents of one <code>List</code> to another.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#addAsList(java.util.List, java.lang.Object)">addAsList</A></B>(java.util.List&nbsp;targetList,
          java.lang.Object&nbsp;sourceList)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add either a single object or List to another List.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#addDisjunctionToSet(java.util.List, java.util.List)">addDisjunctionToSet</A></B>(java.util.List&nbsp;one,
                    java.util.List&nbsp;two)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds elements of the second <code>List</code> that are missing in the first.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#addToIntInMap(java.util.Map, java.lang.Object, int)">addToIntInMap</A></B>(java.util.Map&nbsp;map,
              java.lang.Object&nbsp;key,
              int&nbsp;addition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add to the value of an Integer instance stored in the map "map" under key "key".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#arrayToList(java.lang.Object[])">arrayToList</A></B>(java.lang.Object[]&nbsp;arr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>List</code> from an array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#arrayToList(java.lang.Object[], int, int)">arrayToList</A></B>(java.lang.Object[]&nbsp;arr,
            int&nbsp;from,
            int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>List</code> containing a subset of an array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#arrayUnion(java.lang.Object[], java.lang.Object[])">arrayUnion</A></B>(java.lang.Object[]&nbsp;one,
           java.lang.Object[]&nbsp;two)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new array containing all the elements of two arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#buildList(java.lang.Object)">buildList</A></B>(java.lang.Object&nbsp;one)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>List</code> of one elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#buildList(java.lang.Object, java.lang.Object)">buildList</A></B>(java.lang.Object&nbsp;one,
          java.lang.Object&nbsp;two)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>List</code> of two elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#buildList(java.lang.Object, java.lang.Object, java.lang.Object)">buildList</A></B>(java.lang.Object&nbsp;one,
          java.lang.Object&nbsp;two,
          java.lang.Object&nbsp;three)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>List</code> of three elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#buildList(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">buildList</A></B>(java.lang.Object&nbsp;one,
          java.lang.Object&nbsp;two,
          java.lang.Object&nbsp;three,
          java.lang.Object&nbsp;four)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>List</code> of four elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#buildMap(java.lang.Object, java.lang.Object)">buildMap</A></B>(java.lang.Object&nbsp;key,
         java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>Map</code> of one key/value pair.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#buildMap(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">buildMap</A></B>(java.lang.Object&nbsp;key,
         java.lang.Object&nbsp;value,
         java.lang.Object&nbsp;key2,
         java.lang.Object&nbsp;value2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>Map</code> of two key/value pairs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#buildMap(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">buildMap</A></B>(java.lang.Object&nbsp;key,
         java.lang.Object&nbsp;value,
         java.lang.Object&nbsp;key2,
         java.lang.Object&nbsp;value2,
         java.lang.Object&nbsp;key3,
         java.lang.Object&nbsp;value3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>Map</code> of three key/value pairs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#buildMap(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">buildMap</A></B>(java.lang.Object&nbsp;key,
         java.lang.Object&nbsp;value,
         java.lang.Object&nbsp;key2,
         java.lang.Object&nbsp;value2,
         java.lang.Object&nbsp;key3,
         java.lang.Object&nbsp;value3,
         java.lang.Object&nbsp;key4,
         java.lang.Object&nbsp;value4)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>Map</code> of four key/value pairs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#buildMap(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">buildMap</A></B>(java.lang.Object&nbsp;key,
         java.lang.Object&nbsp;value,
         java.lang.Object&nbsp;key2,
         java.lang.Object&nbsp;value2,
         java.lang.Object&nbsp;key3,
         java.lang.Object&nbsp;value3,
         java.lang.Object&nbsp;key4,
         java.lang.Object&nbsp;value4,
         java.lang.Object&nbsp;key5,
         java.lang.Object&nbsp;value5)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>Map</code> of five key/value pairs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#buildMap(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">buildMap</A></B>(java.lang.Object&nbsp;key,
         java.lang.Object&nbsp;value,
         java.lang.Object&nbsp;key2,
         java.lang.Object&nbsp;value2,
         java.lang.Object&nbsp;key3,
         java.lang.Object&nbsp;value3,
         java.lang.Object&nbsp;key4,
         java.lang.Object&nbsp;value4,
         java.lang.Object&nbsp;key5,
         java.lang.Object&nbsp;value5,
         java.lang.Object&nbsp;key6,
         java.lang.Object&nbsp;value6)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>Map</code> of six key/value pairs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#buildMap(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">buildMap</A></B>(java.lang.Object&nbsp;key,
         java.lang.Object&nbsp;value,
         java.lang.Object&nbsp;key2,
         java.lang.Object&nbsp;value2,
         java.lang.Object&nbsp;key3,
         java.lang.Object&nbsp;value3,
         java.lang.Object&nbsp;key4,
         java.lang.Object&nbsp;value4,
         java.lang.Object&nbsp;key5,
         java.lang.Object&nbsp;value5,
         java.lang.Object&nbsp;key6,
         java.lang.Object&nbsp;value6,
         java.lang.Object&nbsp;key7,
         java.lang.Object&nbsp;value7)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>Map</code> of six key/value pairs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#castValue(java.lang.Object, java.lang.Class, com.isomorphic.datasource.DataSource)">castValue</A></B>(java.lang.Object&nbsp;value,
          java.lang.Class&nbsp;targetType,
          <A HREF="../../../com/isomorphic/datasource/DataSource.html" title="class in com.isomorphic.datasource">DataSource</A>&nbsp;ds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts specified <code>value</code> to <code>targetType</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#checkSize(java.lang.Object)">checkSize</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Obtains the size of a <code>Map</code>, <code>List</code> or <code>String</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#combineAsLists(java.lang.Object, java.lang.Object)">combineAsLists</A></B>(java.lang.Object&nbsp;one,
               java.lang.Object&nbsp;two)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combine two single objects or Lists into one new List, or return a single Object if one
 argument is single and the other argument is null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#contains(java.lang.String, java.lang.String)">contains</A></B>(java.lang.String&nbsp;str,
         java.lang.String&nbsp;substr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests if the specified substring is present in the specified string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#deepMerge(java.lang.Object, java.lang.Object, boolean)">deepMerge</A></B>(java.lang.Object&nbsp;source,
          java.lang.Object&nbsp;target,
          boolean&nbsp;overwrite)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merges one collections data structure into another.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#deepRemoveEmptyCollections(java.lang.Object)">deepRemoveEmptyCollections</A></B>(java.lang.Object&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Walks a nested Collection-based datastructure and removes all Collections entities that are
 zero-sized.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#deepRemoveKey(java.lang.Object, java.lang.Object)">deepRemoveKey</A></B>(java.lang.Object&nbsp;keyToRemove,
              java.lang.Object&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Walks a nested Collection-based datastructure and removes all instances of keyToRemove
 (and its associated value) from any Map objects found in the data structure.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#deepRemoveNullValues(java.lang.Object)">deepRemoveNullValues</A></B>(java.lang.Object&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Walks a nested Collection-based datastructure and removes all entities that have
 a null value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#divideMap(java.util.Map, java.util.List)">divideMap</A></B>(java.util.Map&nbsp;origMap,
          java.util.List&nbsp;retainKeys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alters a <code>Map</code> so that it retains only the specified keys, returning a <code>Map</code>
 with any keys not retained.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#enumToList(java.util.Iterator)">enumToList</A></B>(java.util.Iterator&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts an <code>Iterator</code> to a <code>List</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#fastDateFormat(java.util.Date)">fastDateFormat</A></B>(java.util.Date&nbsp;date)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a <code>String</code> representation of a <code>Date</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#findAll(java.util.List, java.util.Map)">findAll</A></B>(java.util.List&nbsp;rows,
        java.util.Map&nbsp;properties)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a List of Maps, return all Maps that have common key/value pairs with another Map.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#findAll(java.util.List, java.lang.Object, java.lang.Object)">findAll</A></B>(java.util.List&nbsp;rows,
        java.lang.Object&nbsp;propertyName,
        java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a List of Maps, return all Maps that have a certain value for a key.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#formatDate(java.lang.String, java.util.Date)">formatDate</A></B>(java.lang.String&nbsp;format,
           java.util.Date&nbsp;date)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the parameter date formatted according to the parameter format string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getCachedClass(java.lang.String)">getCachedClass</A></B>(java.lang.String&nbsp;className)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns loaded <code>Class</code> object for specified name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.reflect.Field[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getClassFields(java.lang.Class)">getClassFields</A></B>(java.lang.Class&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns array of all fields declared in specified class and it's supper classes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.reflect.Method[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getClassMethods(java.lang.Class)">getClassMethods</A></B>(java.lang.Class&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns array of all methods declared in specified class and it's supper classes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getIntInMap(java.util.Map, java.lang.Object)">getIntInMap</A></B>(java.util.Map&nbsp;map,
            java.lang.Object&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get value of an Integer instance stored in the map "map" under key "key", as the primitive
 type <code>int</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getProperties(java.lang.Object)">getProperties</A></B>(java.lang.Object&nbsp;bean)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the properties for a JavaBean and returns them as a <code>Map</code>.<p/></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getProperty(java.util.List, java.lang.Object)">getProperty</A></B>(java.util.List&nbsp;rows,
            java.lang.Object&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a result set, as a <code>List</code> of rows, and a column name, 
 returns the <code>List</code> of values for that column.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getPropertyDescriptors(java.lang.Class)">getPropertyDescriptors</A></B>(java.lang.Class&nbsp;beanClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the properties for a JavaBean class through introspection and returns them as a <code>Map</code>.<p/>
 Removes properties added by byte-code instrumentation:
 <code>interceptFieldCallback</code> property is removed if class implements
 <code>net.sf.cglib.transform.impl.InterceptFieldEnabled</code> interface;
 <code>fieldHandler</code> property is removed if class implements
 <code>org.hibernate.bytecode.javassist.FieldHandled</code> interface;
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getPropertyDescriptors(java.lang.Object)">getPropertyDescriptors</A></B>(java.lang.Object&nbsp;bean)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the property descriptors for a JavaBean and returns them as a <code>Map</code>.<p/></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getPropertyType(java.lang.Class, java.lang.String)">getPropertyType</A></B>(java.lang.Class&nbsp;c,
                java.lang.String&nbsp;propertyName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns type of specified property in provided class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getRealClass(java.lang.Object)">getRealClass</A></B>(java.lang.Object&nbsp;bean)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if provided bean is a proxy and extracts real class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getSingle(java.lang.Object)">getSingle</A></B>(java.lang.Object&nbsp;toFetchFrom)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the element of a single element <code>List</code>, or the key
 of a single key/value pair <code>Map</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getStackTrace(java.lang.Throwable)">getStackTrace</A></B>(java.lang.Throwable&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the stack trace of a <code>Throwable</code> object as a <code>String</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#getterName(java.lang.reflect.Method)">getterName</A></B>(java.lang.reflect.Method&nbsp;method)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests if method is getter and returns property name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#hashValue(java.lang.String)">hashValue</A></B>(java.lang.String&nbsp;plaintext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the hash of the passed-in string, encrypted using the MD5 algorithm</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#hashValue(java.lang.String, java.lang.String)">hashValue</A></B>(java.lang.String&nbsp;plaintext,
          java.lang.String&nbsp;algorithm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the hash of the passed-in string, encrypted using the specified algorithm</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#identityMap(java.util.List)">identityMap</A></B>(java.util.List&nbsp;list)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stores the elements of a <code>List</code> as the keys and values of a <code>Map</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#incrementIntInMap(java.util.Map, java.lang.Object)">incrementIntInMap</A></B>(java.util.Map&nbsp;map,
                  java.lang.Object&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add to the value of an Integer instance stored in the map "map" under key "key".</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#isNumberType(java.lang.Class)">isNumberType</A></B>(java.lang.Class&nbsp;clazz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if provided class is either assignable to <code>Number</code> or
 represents one of primitive number types <code>byte, short, int, long, float, double</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#isTextType(java.lang.Class)">isTextType</A></B>(java.lang.Class&nbsp;clazz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if provided class is either assignable to <code>Character</code> or
 assignable to <code>String</code> or represents primitive <code>char</code> type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#jxPathContext(java.lang.Object)">jxPathContext</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns JXPathContext in lenient mode</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#keysAsList(java.util.Map)">keysAsList</A></B>(java.util.Map&nbsp;map)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>List</code> of the keys from a <code>Map</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#keysNotPresent(java.util.Map, java.util.List)">keysNotPresent</A></B>(java.util.Map&nbsp;map,
               java.util.List&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a <code>Map</code> and a <code>List</code> of keys, returns the list of keys
 in the <code>List</code> that are not present in the <code>Map</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#listToArray(java.util.List)">listToArray</A></B>(java.util.List&nbsp;list)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an <code>Object</code> array from a <code>List</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#listToStringArray(java.util.Collection)">listToStringArray</A></B>(java.util.Collection&nbsp;list)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>String</code> array from a <code>List</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#makeList(java.lang.Object)">makeList</A></B>(java.lang.Object&nbsp;element)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>List</code> containing one element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#makeListIfSingle(java.lang.Object)">makeListIfSingle</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>List</code> containing one element <i>if</i> the element
 is not a <code>List</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#mapDisjunction(java.util.Map, java.util.Map)">mapDisjunction</A></B>(java.util.Map&nbsp;one,
               java.util.Map&nbsp;two)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <code>Map</code> containing the key/value pairs whose keys
 are not present in <i>both</i> <code>Maps</code> supplied.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#mapIntersection(java.util.Map, java.util.Map)">mapIntersection</A></B>(java.util.Map&nbsp;primary,
                java.util.Map&nbsp;secondary)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a <code>Map</code> containing the key/value pairs of the primary
 <code>Map</code> whose keys are present in the secondary <code>Map</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#mapIntersectionKeys(java.util.Map, java.util.Map)">mapIntersectionKeys</A></B>(java.util.Map&nbsp;one,
                    java.util.Map&nbsp;two)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the list of keys that are present in both <code>Maps</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#mapMerge(java.util.Map, java.util.Map)">mapMerge</A></B>(java.util.Map&nbsp;source,
         java.util.Map&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the key/value pairs of a <code>Map</code> into another <code>Map</code>,
 replacing the key/value pair of the target <code>Map</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#mapMergeNonNull(java.util.Map, java.util.Map)">mapMergeNonNull</A></B>(java.util.Map&nbsp;source,
                java.util.Map&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the key/value pairs of a <code>Map</code> into another <code>Map</code>,
 replacing the key/value pair of the target <code>Map</code> if the source value
 is non-null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Properties</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#mapToProperties(java.util.Map)">mapToProperties</A></B>(java.util.Map&nbsp;map)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>Properties</code> object from a <code>Map</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#mapUnion(java.util.Map, java.util.Map)">mapUnion</A></B>(java.util.Map&nbsp;primary,
         java.util.Map&nbsp;secondary)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a <code>Map</code> containing all the key/value pairs of the
 <code>Maps</code> supplied as arguments, with the first <code>Map</code> taking
 precedence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#md5(java.lang.String)">md5</A></B>(java.lang.String&nbsp;plaintext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the hash of the passed-in string, encrypted using the MD5 algorithm</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#nestedGet(java.lang.Object, java.lang.String)">nestedGet</A></B>(java.lang.Object&nbsp;struct,
          java.lang.String&nbsp;fetch)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a object from a series of nested <code>Lists</code> or <code>Map</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.LinkedHashMap</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#orderedMapUnion(java.util.Map, java.util.Map)">orderedMapUnion</A></B>(java.util.Map&nbsp;primary,
                java.util.Map&nbsp;secondary)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does the same as <A HREF="../../../com/isomorphic/util/DataTools.html#mapUnion(java.util.Map, java.util.Map)"><CODE>mapUnion</CODE></A>, but keeps order of 
 key/value pairs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#prettyPrint(java.lang.Object)">prettyPrint</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formats information about an <code>Object</code> for viewing or printing as 
 a <code>String</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#putAllNotPresent(java.util.Map, java.util.Map)">putAllNotPresent</A></B>(java.util.Map&nbsp;target,
                 java.util.Map&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the key/value pairs of a <code>Map</code> into another <code>Map</code>, 
 adding only key/value pairs for which the target <code>Map</code> does not 
 already have a mapping (as determined by the <code>containsKey</code> method).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#putCombinedList(java.util.Map, java.lang.Object, java.lang.Object)">putCombinedList</A></B>(java.util.Map&nbsp;map,
                java.lang.Object&nbsp;key,
                java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Put a value into a Map, combining with any existing value as though combineAsLists() had been
 called on the existing value and new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#putMultiple(java.util.Map, java.lang.Object, java.lang.Object)">putMultiple</A></B>(java.util.Map&nbsp;map,
            java.lang.Object&nbsp;key,
            java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Puts a key/value pair into a <code>Map</code>, if there is already a value 
 under that key, create a <code>List</code> to hold the values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#putMultipleAsList(java.util.Map, java.lang.Object, java.lang.Object)">putMultipleAsList</A></B>(java.util.Map&nbsp;map,
                  java.lang.Object&nbsp;key,
                  java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Works like the <code>putMultiple</code> method, but in this case 
 values are always encapsualted in a <code>List</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#recursiveFileDelete(java.io.File)">recursiveFileDelete</A></B>(java.io.File&nbsp;file)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Recursively deletes a directory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#registerTransformer(java.lang.Class, com.isomorphic.util.DataTools.Transformer)">registerTransformer</A></B>(java.lang.Class&nbsp;targetType,
                    <A HREF="../../../com/isomorphic/util/DataTools.Transformer.html" title="interface in com.isomorphic.util">DataTools.Transformer</A>&nbsp;transformer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register a Transformer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#remapRow(java.util.Map, java.util.Map)">remapRow</A></B>(java.util.Map&nbsp;row,
         java.util.Map&nbsp;remap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Change the keys used in a <code>Map</code> to a new set of keys.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#remapRow(java.util.Map, java.util.Map, boolean)">remapRow</A></B>(java.util.Map&nbsp;row,
         java.util.Map&nbsp;remap,
         boolean&nbsp;keepNonRemapped)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Change the keys used in a <code>Map</code> to a new set of keys.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#remapRows(java.util.List, java.util.Map)">remapRows</A></B>(java.util.List&nbsp;rows,
          java.util.Map&nbsp;remap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remap the keys in a <code>List</code> of <code>Maps</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#remapRows(java.util.List, java.util.Map, boolean)">remapRows</A></B>(java.util.List&nbsp;rows,
          java.util.Map&nbsp;remap,
          boolean&nbsp;keepNonRemapped)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remap the keys in a <code>List</code> of <code>Maps</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#removeEmptyStringValuedKeys(java.util.Map)">removeEmptyStringValuedKeys</A></B>(java.util.Map&nbsp;map)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all keys from the passed-in <code><i>map</i></code> where the values are empty strings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#removeNullValuedKeys(java.util.Map)">removeNullValuedKeys</A></B>(java.util.Map&nbsp;map)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all keys from the passed-in <code><i>map</i></code> where the values 
 are <code>null</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#reverseMap(java.util.Map)">reverseMap</A></B>(java.util.Map&nbsp;origMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reverses a <code>Map</code> so that values point at keys.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#setDisjunction(java.util.Collection, java.util.Collection)">setDisjunction</A></B>(java.util.Collection&nbsp;one,
               java.util.Collection&nbsp;two)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <code>List</code> containing all elements from the first
 <code>Collection</code> that are <i>not</i> in the second <code>Collection</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#setIntersection(java.util.Collection, java.util.Collection)">setIntersection</A></B>(java.util.Collection&nbsp;one,
                java.util.Collection&nbsp;two)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <code>List</code> containing the common elements of two <code>Collections</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#setProperties(java.util.Map, java.lang.Object)">setProperties</A></B>(java.util.Map&nbsp;propertyMap,
              java.lang.Object&nbsp;bean)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As the three-argument version of this method, but passes a null dataSource</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#setProperties(java.util.Map, java.lang.Object, com.isomorphic.datasource.DataSource)">setProperties</A></B>(java.util.Map&nbsp;propertyMap,
              java.lang.Object&nbsp;bean,
              <A HREF="../../../com/isomorphic/datasource/DataSource.html" title="class in com.isomorphic.datasource">DataSource</A>&nbsp;ds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the properties for a JavaBean provided as key-value pairs in a <code>Map</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#setProperties(java.util.Map, java.lang.Object, com.isomorphic.datasource.DataSource, com.isomorphic.datasource.DSRequest)">setProperties</A></B>(java.util.Map&nbsp;propertyMap,
              java.lang.Object&nbsp;bean,
              <A HREF="../../../com/isomorphic/datasource/DataSource.html" title="class in com.isomorphic.datasource">DataSource</A>&nbsp;ds,
              <A HREF="../../../com/isomorphic/datasource/DSRequest.html" title="class in com.isomorphic.datasource">DSRequest</A>&nbsp;dsRequest)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This version of setProperties accepts a DSRequest for use as context by the conversion
 process.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#setUnion(java.util.List, java.util.List)">setUnion</A></B>(java.util.List&nbsp;one,
         java.util.List&nbsp;two)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new <code>List</code> containing all the elements of two <code>Lists</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#sha(java.lang.String)">sha</A></B>(java.lang.String&nbsp;plaintext)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the hash of the passed-in string, encrypted using the SHA-1 algorithm</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#subsetByPrefix(java.util.List, java.lang.String)">subsetByPrefix</A></B>(java.util.List&nbsp;list,
               java.lang.String&nbsp;prefix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns any strings within <code><i>list</i></code> which begin with 
 <code><i>prefix</i></code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#subsetMap(java.util.Map, java.util.List)">subsetMap</A></B>(java.util.Map&nbsp;origMap,
          java.util.List&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a <code>Map</code> and a <code>List</code> of keys, returns a subset of the <code>Map</code>
 containing the key/value pairs as specified by the <code>List</code> of keys.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#substringKeyMap(java.lang.String, java.util.Map)">substringKeyMap</A></B>(java.lang.String&nbsp;prefix,
                java.util.Map&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a <code>Map</code> of key/value pairs from the source
 <code>Map</code> whose keys start with a specific prefix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/isomorphic/util/DataTools.html#toLowerCaseList(java.util.List)">toLowerCaseList</A></B>(java.util.List&nbsp;list)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given a <code>List</code> of strings, returns a new <code>List</code> of lower cased strings.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="keysNotPresent(java.util.Map, java.util.List)"><!-- --></A><H3>
keysNotPresent</H3>
<PRE>
public static java.util.List <B>keysNotPresent</B>(java.util.Map&nbsp;map,
                                            java.util.List&nbsp;keys)</PRE>
<DL>
<DD>Given a <code>Map</code> and a <code>List</code> of keys, returns the list of keys
 in the <code>List</code> that are not present in the <code>Map</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>map</CODE> - the <code>Map</code><DD><CODE>keys</CODE> - the <code>List</code> of keys
<DT><B>Returns:</B><DD>the list of keys in the supplied <code>List</code> that are not
                        present in the <code>Map</code></DL>
</DD>
</DL>
<HR>

<A NAME="subsetMap(java.util.Map, java.util.List)"><!-- --></A><H3>
subsetMap</H3>
<PRE>
public static java.util.Map <B>subsetMap</B>(java.util.Map&nbsp;origMap,
                                      java.util.List&nbsp;keys)</PRE>
<DL>
<DD>Given a <code>Map</code> and a <code>List</code> of keys, returns a subset of the <code>Map</code>
 containing the key/value pairs as specified by the <code>List</code> of keys.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>origMap</CODE> - the original <code>Map</code><DD><CODE>keys</CODE> - the keys denoting the key/value pairs that should be
                  included in the result <code>Map</code>
<DT><B>Returns:</B><DD>the subset of the original <code>Map</code> containing only the
                        key/value pairs corresponding to the supplied <code>List</code> 
                                        of keys</DL>
</DD>
</DL>
<HR>

<A NAME="subsetByPrefix(java.util.List, java.lang.String)"><!-- --></A><H3>
subsetByPrefix</H3>
<PRE>
public static java.util.List <B>subsetByPrefix</B>(java.util.List&nbsp;list,
                                            java.lang.String&nbsp;prefix)</PRE>
<DL>
<DD>Returns any strings within <code><i>list</i></code> which begin with 
 <code><i>prefix</i></code>. Non-string members of <code><i>list</i></code> are ignored.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the list of strings<DD><CODE>prefix</CODE> - strings in the list with this prefix will be returned
<DT><B>Returns:</B><DD>a list of the strings in the supplied list that begin with the
                        specified prefix</DL>
</DD>
</DL>
<HR>

<A NAME="removeNullValuedKeys(java.util.Map)"><!-- --></A><H3>
removeNullValuedKeys</H3>
<PRE>
public static java.util.Map <B>removeNullValuedKeys</B>(java.util.Map&nbsp;map)</PRE>
<DL>
<DD>Removes all keys from the passed-in <code><i>map</i></code> where the values 
 are <code>null</code>.  
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>map</CODE> - the <code>Map</code> on which to operate</DL>
</DD>
</DL>
<HR>

<A NAME="removeEmptyStringValuedKeys(java.util.Map)"><!-- --></A><H3>
removeEmptyStringValuedKeys</H3>
<PRE>
public static java.util.Map <B>removeEmptyStringValuedKeys</B>(java.util.Map&nbsp;map)</PRE>
<DL>
<DD>Removes all keys from the passed-in <code><i>map</i></code> where the values are empty strings.  
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>map</CODE> - the <code>Map</code> on which to operate</DL>
</DD>
</DL>
<HR>

<A NAME="divideMap(java.util.Map, java.util.List)"><!-- --></A><H3>
divideMap</H3>
<PRE>
public static java.util.Map <B>divideMap</B>(java.util.Map&nbsp;origMap,
                                      java.util.List&nbsp;retainKeys)</PRE>
<DL>
<DD>Alters a <code>Map</code> so that it retains only the specified keys, returning a <code>Map</code>
 with any keys not retained.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>origMap</CODE> - the original <code>Map</code><DD><CODE>retainKeys</CODE> - the <code>List</code> of keys corresponding to the key/value pairs 
                                                that should be retained
<DT><B>Returns:</B><DD>a <code>Map</code> containing the key/value pairs that were not retained</DL>
</DD>
</DL>
<HR>

<A NAME="mapUnion(java.util.Map, java.util.Map)"><!-- --></A><H3>
mapUnion</H3>
<PRE>
public static java.util.Map <B>mapUnion</B>(java.util.Map&nbsp;primary,
                                     java.util.Map&nbsp;secondary)</PRE>
<DL>
<DD>Constructs a <code>Map</code> containing all the key/value pairs of the
 <code>Maps</code> supplied as arguments, with the first <code>Map</code> taking
 precedence. If the same key is present in both <code>Maps</code>, the
 returned <code>Map</code> will contain the key/value pair of the first 
 <code>Map</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first <code>Map</code><DD><CODE>two</CODE> - the second <code>Map</code>
<DT><B>Returns:</B><DD>the union of the two <code>Maps</code></DL>
</DD>
</DL>
<HR>

<A NAME="orderedMapUnion(java.util.Map, java.util.Map)"><!-- --></A><H3>
orderedMapUnion</H3>
<PRE>
public static java.util.LinkedHashMap <B>orderedMapUnion</B>(java.util.Map&nbsp;primary,
                                                      java.util.Map&nbsp;secondary)</PRE>
<DL>
<DD>Does the same as <A HREF="../../../com/isomorphic/util/DataTools.html#mapUnion(java.util.Map, java.util.Map)"><CODE>mapUnion</CODE></A>, but keeps order of 
 key/value pairs. Key/value pairs of primary <code>Map</code> will go first, 
 then key/value pairs from secondary <code>Map</code> ignoring dublicates.
 Consider using <code>LinkedHashMap</code> for primary and secondary maps 
 to get full value from this method.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first <code>Map</code><DD><CODE>two</CODE> - the second <code>Map</code>
<DT><B>Returns:</B><DD>the union of the two <code>Maps</code></DL>
</DD>
</DL>
<HR>

<A NAME="deepMerge(java.lang.Object, java.lang.Object, boolean)"><!-- --></A><H3>
deepMerge</H3>
<PRE>
public static java.lang.Object <B>deepMerge</B>(java.lang.Object&nbsp;source,
                                         java.lang.Object&nbsp;target,
                                         boolean&nbsp;overwrite)
                                  throws java.lang.Exception</PRE>
<DL>
<DD>Merges one collections data structure into another.  Any nodes/items
 not present in the target get created.  Those that are present are merged.
 Note that the initial source and target must be of the same type and their
 data must not contain conflicting types.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - the <code>Object</code> to be copied from<DD><CODE>target</CODE> - the <code>Object</code> to be copied into<DD><CODE>overwrite</CODE> - controls how non-collection/non-map collisions are resolved.  If true,
                  target values are overwritten with source values.  If false, target
                  values are not overwritten.
<DT><B>Returns:</B><DD>the merged <code>Object</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="deepRemoveKey(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
deepRemoveKey</H3>
<PRE>
public static void <B>deepRemoveKey</B>(java.lang.Object&nbsp;keyToRemove,
                                 java.lang.Object&nbsp;data)
                          throws java.lang.Exception</PRE>
<DL>
<DD>Walks a nested Collection-based datastructure and removes all instances of keyToRemove
 (and its associated value) from any Map objects found in the data structure.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>keyToRemove</CODE> - the key to remove<DD><CODE>data</CODE> - the nested data structure to walk
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="deepRemoveNullValues(java.lang.Object)"><!-- --></A><H3>
deepRemoveNullValues</H3>
<PRE>
public static void <B>deepRemoveNullValues</B>(java.lang.Object&nbsp;data)
                                 throws java.lang.Exception</PRE>
<DL>
<DD>Walks a nested Collection-based datastructure and removes all entities that have
 a null value.  For Maps this means the removal of keys with a value of null, for
 Collections this means the removel of null elements.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - the nested data structure to walk
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="deepRemoveEmptyCollections(java.lang.Object)"><!-- --></A><H3>
deepRemoveEmptyCollections</H3>
<PRE>
public static void <B>deepRemoveEmptyCollections</B>(java.lang.Object&nbsp;data)
                                       throws java.lang.Exception</PRE>
<DL>
<DD>Walks a nested Collection-based datastructure and removes all Collections entities that are
 zero-sized.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - the nested data structure to walk
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="mapMerge(java.util.Map, java.util.Map)"><!-- --></A><H3>
mapMerge</H3>
<PRE>
public static java.util.Map <B>mapMerge</B>(java.util.Map&nbsp;source,
                                     java.util.Map&nbsp;target)</PRE>
<DL>
<DD>Copies the key/value pairs of a <code>Map</code> into another <code>Map</code>,
 replacing the key/value pair of the target <code>Map</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - the <code>Map</code> to be copied from<DD><CODE>target</CODE> - the <code>Map</code> to be copied into
<DT><B>Returns:</B><DD>the merged <code>Map</code></DL>
</DD>
</DL>
<HR>

<A NAME="mapMergeNonNull(java.util.Map, java.util.Map)"><!-- --></A><H3>
mapMergeNonNull</H3>
<PRE>
public static java.util.Map <B>mapMergeNonNull</B>(java.util.Map&nbsp;source,
                                            java.util.Map&nbsp;target)</PRE>
<DL>
<DD>Copies the key/value pairs of a <code>Map</code> into another <code>Map</code>,
 replacing the key/value pair of the target <code>Map</code> if the source value
 is non-null.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - the <code>Map</code> to be copied from<DD><CODE>target</CODE> - the <code>Map</code> to be copied into
<DT><B>Returns:</B><DD>the merged <code>Map</code></DL>
</DD>
</DL>
<HR>

<A NAME="putAllNotPresent(java.util.Map, java.util.Map)"><!-- --></A><H3>
putAllNotPresent</H3>
<PRE>
public static java.util.Map <B>putAllNotPresent</B>(java.util.Map&nbsp;target,
                                             java.util.Map&nbsp;source)</PRE>
<DL>
<DD>Copies the key/value pairs of a <code>Map</code> into another <code>Map</code>, 
 adding only key/value pairs for which the target <code>Map</code> does not 
 already have a mapping (as determined by the <code>containsKey</code> method).
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - the <code>Map</code> to be copied from<DD><CODE>target</CODE> - the <code>Map</code> to be copied into
<DT><B>Returns:</B><DD>the merged <code>Map</code></DL>
</DD>
</DL>
<HR>

<A NAME="mapIntersection(java.util.Map, java.util.Map)"><!-- --></A><H3>
mapIntersection</H3>
<PRE>
public static java.util.Map <B>mapIntersection</B>(java.util.Map&nbsp;primary,
                                            java.util.Map&nbsp;secondary)</PRE>
<DL>
<DD>Constructs a <code>Map</code> containing the key/value pairs of the primary
 <code>Map</code> whose keys are present in the secondary <code>Map</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>primary</CODE> - the primary <code>Map</code><DD><CODE>secondary</CODE> - the secondary <code>Map</code>
<DT><B>Returns:</B><DD>the intersection of the two <code>Map</code></DL>
</DD>
</DL>
<HR>

<A NAME="mapIntersectionKeys(java.util.Map, java.util.Map)"><!-- --></A><H3>
mapIntersectionKeys</H3>
<PRE>
public static java.util.List <B>mapIntersectionKeys</B>(java.util.Map&nbsp;one,
                                                 java.util.Map&nbsp;two)</PRE>
<DL>
<DD>Returns the list of keys that are present in both <code>Maps</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first <code>Map</code><DD><CODE>two</CODE> - the second <code>Map</code>
<DT><B>Returns:</B><DD>the list of keys that is the intersection of the <code>Maps</code></DL>
</DD>
</DL>
<HR>

<A NAME="substringKeyMap(java.lang.String, java.util.Map)"><!-- --></A><H3>
substringKeyMap</H3>
<PRE>
public static java.util.Map <B>substringKeyMap</B>(java.lang.String&nbsp;prefix,
                                            java.util.Map&nbsp;source)</PRE>
<DL>
<DD>Constructs a <code>Map</code> of key/value pairs from the source
 <code>Map</code> whose keys start with a specific prefix. The new
 <code>Map</code>'s keys are the origin keys <i>without</i> the prefix.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>prefix</CODE> - the prefix to be matched with the keys<DD><CODE>source</CODE> - the source <code>Map</code>
<DT><B>Returns:</B><DD>the new <code>Map</code></DL>
</DD>
</DL>
<HR>

<A NAME="identityMap(java.util.List)"><!-- --></A><H3>
identityMap</H3>
<PRE>
public static java.util.Map <B>identityMap</B>(java.util.List&nbsp;list)</PRE>
<DL>
<DD>Stores the elements of a <code>List</code> as the keys and values of a <code>Map</code>.  
 This can serve as a <code>HashSet</code> which disallows duplicates and can quickly 
 determine whether a set has a given member.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the <code>List</code> to be stored
<DT><B>Returns:</B><DD>the <code>Map</code> containing the uniques elements of the list</DL>
</DD>
</DL>
<HR>

<A NAME="reverseMap(java.util.Map)"><!-- --></A><H3>
reverseMap</H3>
<PRE>
public static java.util.Map <B>reverseMap</B>(java.util.Map&nbsp;origMap)</PRE>
<DL>
<DD>Reverses a <code>Map</code> so that values point at keys. If more than one
 value in the original <code>Map</code> has the same key (where "same" is
 determined by <code>hashcode</code>), the multiple keys are placed into a 
 <code>List</code> in the reversed <code>Map</code>.
 <p>
 <b>Note:</b> If in the original <code>Map</code>, <code>Lists</code> are 
 mapped to values, and more than one <code>List</code> maps to the same 
 value, this method will work incorrectly since it won't be able to tell 
 <code>Lists</code> it created for multiple values from <code>Lists</code>
 that were keys in the original <code>Map</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>origMap</CODE> - the original <code>Map</code>
<DT><B>Returns:</B><DD>the reversed <code>Map</code></DL>
</DD>
</DL>
<HR>

<A NAME="putMultiple(java.util.Map, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
putMultiple</H3>
<PRE>
public static java.util.Map <B>putMultiple</B>(java.util.Map&nbsp;map,
                                        java.lang.Object&nbsp;key,
                                        java.lang.Object&nbsp;value)</PRE>
<DL>
<DD>Puts a key/value pair into a <code>Map</code>, if there is already a value 
 under that key, create a <code>List</code> to hold the values.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>map</CODE> - the <code>Map</code> to which the key/value pair should be added<DD><CODE>key</CODE> - the key in the key/value pair<DD><CODE>value</CODE> - the value in the key/value pair
<DT><B>Returns:</B><DD>the <code>Map</code>, with the key/value pair added to it</DL>
</DD>
</DL>
<HR>

<A NAME="putMultipleAsList(java.util.Map, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
putMultipleAsList</H3>
<PRE>
public static java.util.Map <B>putMultipleAsList</B>(java.util.Map&nbsp;map,
                                              java.lang.Object&nbsp;key,
                                              java.lang.Object&nbsp;value)</PRE>
<DL>
<DD>Works like the <code>putMultiple</code> method, but in this case 
 values are always encapsualted in a <code>List</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>map</CODE> - the <code>Map</code> to which the key/value pair should be added<DD><CODE>key</CODE> - the key in the key/value pair<DD><CODE>value</CODE> - the value in the key/value pair
<DT><B>Returns:</B><DD>the <code>Map</code>, with the key/value pair added to it</DL>
</DD>
</DL>
<HR>

<A NAME="addAll(java.util.List, java.util.List)"><!-- --></A><H3>
addAll</H3>
<PRE>
public static java.util.List <B>addAll</B>(java.util.List&nbsp;target,
                                    java.util.List&nbsp;source)</PRE>
<DL>
<DD>Adds the contents of one <code>List</code> to another.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - the <code>List</code> to which the contents of the 
                                        source <code>List</code> should be added<DD><CODE>source</CODE> - the <code>List</code> to be added to the target 
                                        <code>List</code>
<DT><B>Returns:</B><DD>the combined <code>List</code></DL>
</DD>
</DL>
<HR>

<A NAME="addAll(java.util.List, java.util.Iterator)"><!-- --></A><H3>
addAll</H3>
<PRE>
public static java.util.List <B>addAll</B>(java.util.List&nbsp;target,
                                    java.util.Iterator&nbsp;source)</PRE>
<DL>
<DD>Adds all the elements of an <code>Iterator</code> to a <code>List</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - the <code>List</code> to which the contents of the 
                                        source <code>List</code> should be added<DD><CODE>source</CODE> - the <code>List</code> to be added to the target 
                                        <code>List</code>
<DT><B>Returns:</B><DD>the combined <code>List</code></DL>
</DD>
</DL>
<HR>

<A NAME="addAsList(java.util.List, java.lang.Object)"><!-- --></A><H3>
addAsList</H3>
<PRE>
public static java.util.List <B>addAsList</B>(java.util.List&nbsp;targetList,
                                       java.lang.Object&nbsp;sourceList)</PRE>
<DL>
<DD>Add either a single object or List to another List.  If <code>sourceList</code> is a List,
 adds its items, if it's an Object, just adds the Object itself.  Returns the modified
 <code>targetList</code>.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="combineAsLists(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
combineAsLists</H3>
<PRE>
public static java.lang.Object <B>combineAsLists</B>(java.lang.Object&nbsp;one,
                                              java.lang.Object&nbsp;two)</PRE>
<DL>
<DD>Combine two single objects or Lists into one new List, or return a single Object if one
 argument is single and the other argument is null.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="putCombinedList(java.util.Map, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
putCombinedList</H3>
<PRE>
public static java.util.Map <B>putCombinedList</B>(java.util.Map&nbsp;map,
                                            java.lang.Object&nbsp;key,
                                            java.lang.Object&nbsp;value)</PRE>
<DL>
<DD>Put a value into a Map, combining with any existing value as though combineAsLists() had been
 called on the existing value and new value.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUnion(java.util.List, java.util.List)"><!-- --></A><H3>
setUnion</H3>
<PRE>
public static java.util.List <B>setUnion</B>(java.util.List&nbsp;one,
                                      java.util.List&nbsp;two)</PRE>
<DL>
<DD>Creates a new <code>List</code> containing all the elements of two <code>Lists</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first <code>List</code><DD><CODE>two</CODE> - the second <code>List</code>
<DT><B>Returns:</B><DD>the combined <code>List</code></DL>
</DD>
</DL>
<HR>

<A NAME="addDisjunctionToSet(java.util.List, java.util.List)"><!-- --></A><H3>
addDisjunctionToSet</H3>
<PRE>
public static void <B>addDisjunctionToSet</B>(java.util.List&nbsp;one,
                                       java.util.List&nbsp;two)</PRE>
<DL>
<DD>Adds elements of the second <code>List</code> that are missing in the first. 
 If the first or second <code>List</code> is <code>null</code>, the first 
 will be unchanged.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first <code>List</code><DD><CODE>two</CODE> - the second <code>List</code></DL>
</DD>
</DL>
<HR>

<A NAME="arrayUnion(java.lang.Object[], java.lang.Object[])"><!-- --></A><H3>
arrayUnion</H3>
<PRE>
public static java.lang.Object[] <B>arrayUnion</B>(java.lang.Object[]&nbsp;one,
                                            java.lang.Object[]&nbsp;two)</PRE>
<DL>
<DD>Creates a new array containing all the elements of two arrays.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first array<DD><CODE>two</CODE> - the second array
<DT><B>Returns:</B><DD>the combined array</DL>
</DD>
</DL>
<HR>

<A NAME="setIntersection(java.util.Collection, java.util.Collection)"><!-- --></A><H3>
setIntersection</H3>
<PRE>
public static java.util.List <B>setIntersection</B>(java.util.Collection&nbsp;one,
                                             java.util.Collection&nbsp;two)</PRE>
<DL>
<DD>Creates a new <code>List</code> containing the common elements of two <code>Collections</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first <code>Collection</code><DD><CODE>two</CODE> - the second <code>Collection</code>
<DT><B>Returns:</B><DD>the common elements</DL>
</DD>
</DL>
<HR>

<A NAME="mapDisjunction(java.util.Map, java.util.Map)"><!-- --></A><H3>
mapDisjunction</H3>
<PRE>
public static java.util.Map <B>mapDisjunction</B>(java.util.Map&nbsp;one,
                                           java.util.Map&nbsp;two)</PRE>
<DL>
<DD>Creates a new <code>Map</code> containing the key/value pairs whose keys
 are not present in <i>both</i> <code>Maps</code> supplied.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first <code>Map</code><DD><CODE>two</CODE> - the second <code>Map</code>
<DT><B>Returns:</B><DD>the <code>Map</code> of the disjunction</DL>
</DD>
</DL>
<HR>

<A NAME="setDisjunction(java.util.Collection, java.util.Collection)"><!-- --></A><H3>
setDisjunction</H3>
<PRE>
public static java.util.List <B>setDisjunction</B>(java.util.Collection&nbsp;one,
                                            java.util.Collection&nbsp;two)</PRE>
<DL>
<DD>Creates a new <code>List</code> containing all elements from the first
 <code>Collection</code> that are <i>not</i> in the second <code>Collection</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first <code>Collection</code><DD><CODE>two</CODE> - the second <code>Collection</code>
<DT><B>Returns:</B><DD>the <code>List</code> of elements present in the first 
                                <code>List</code> that are not in the second <code>List</code></DL>
</DD>
</DL>
<HR>

<A NAME="enumToList(java.util.Iterator)"><!-- --></A><H3>
enumToList</H3>
<PRE>
public static java.util.List <B>enumToList</B>(java.util.Iterator&nbsp;i)</PRE>
<DL>
<DD>Converts an <code>Iterator</code> to a <code>List</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the <code>Iterator</code>
<DT><B>Returns:</B><DD>the <code>List</code> of <code>Iterator</code> elements</DL>
</DD>
</DL>
<HR>

<A NAME="arrayToList(java.lang.Object[], int, int)"><!-- --></A><H3>
arrayToList</H3>
<PRE>
public static java.util.List <B>arrayToList</B>(java.lang.Object[]&nbsp;arr,
                                         int&nbsp;from,
                                         int&nbsp;length)</PRE>
<DL>
<DD>Creates a <code>List</code> containing a subset of an array.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>arr</CODE> - the source array<DD><CODE>from</CODE> - the array index of the first element of the subset<DD><CODE>length</CODE> - the number of elements in the subset
<DT><B>Returns:</B><DD>the <code>List</code> of elements from the subset of the source array</DL>
</DD>
</DL>
<HR>

<A NAME="arrayToList(java.lang.Object[])"><!-- --></A><H3>
arrayToList</H3>
<PRE>
public static java.util.List <B>arrayToList</B>(java.lang.Object[]&nbsp;arr)</PRE>
<DL>
<DD>Creates a <code>List</code> from an array.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>arr</CODE> - the source array
<DT><B>Returns:</B><DD>the <code>List</code> of elements from the source array</DL>
</DD>
</DL>
<HR>

<A NAME="listToArray(java.util.List)"><!-- --></A><H3>
listToArray</H3>
<PRE>
public static java.lang.Object[] <B>listToArray</B>(java.util.List&nbsp;list)</PRE>
<DL>
<DD>Creates an <code>Object</code> array from a <code>List</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the source <code>List</code>
<DT><B>Returns:</B><DD>the <code>Object</code> array containing the elements 
                                        of the source list</DL>
</DD>
</DL>
<HR>

<A NAME="listToStringArray(java.util.Collection)"><!-- --></A><H3>
listToStringArray</H3>
<PRE>
public static java.lang.String[] <B>listToStringArray</B>(java.util.Collection&nbsp;list)</PRE>
<DL>
<DD>Creates a <code>String</code> array from a <code>List</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the source <code>List</code>
<DT><B>Returns:</B><DD>the array of <code>Strings</code> from the source <code>List</code></DL>
</DD>
</DL>
<HR>

<A NAME="mapToProperties(java.util.Map)"><!-- --></A><H3>
mapToProperties</H3>
<PRE>
public static java.util.Properties <B>mapToProperties</B>(java.util.Map&nbsp;map)</PRE>
<DL>
<DD>Creates a <code>Properties</code> object from a <code>Map</code>. The keys and 
 values in the map <i>must</i> be strings.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>map</CODE> - the source <code>Map</code>
<DT><B>Returns:</B><DD>the <code>Properties</code> object containing the keys/values 
                                of the source <code>Map</code> as properties</DL>
</DD>
</DL>
<HR>

<A NAME="keysAsList(java.util.Map)"><!-- --></A><H3>
keysAsList</H3>
<PRE>
public static java.util.List <B>keysAsList</B>(java.util.Map&nbsp;map)</PRE>
<DL>
<DD>Creates a <code>List</code> of the keys from a <code>Map</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>map</CODE> - the source <code>Map</code>
<DT><B>Returns:</B><DD>the list of keys from the source <code>Map</code></DL>
</DD>
</DL>
<HR>

<A NAME="makeList(java.lang.Object)"><!-- --></A><H3>
makeList</H3>
<PRE>
public static java.util.List <B>makeList</B>(java.lang.Object&nbsp;element)</PRE>
<DL>
<DD>Creates a <code>List</code> containing one element.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>element</CODE> - the element
<DT><B>Returns:</B><DD>the <code>List</code> containing the element</DL>
</DD>
</DL>
<HR>

<A NAME="makeListIfSingle(java.lang.Object)"><!-- --></A><H3>
makeListIfSingle</H3>
<PRE>
public static java.util.List <B>makeListIfSingle</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Creates a <code>List</code> containing one element <i>if</i> the element
 is not a <code>List</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the element
<DT><B>Returns:</B><DD>the <code>List</code></DL>
</DD>
</DL>
<HR>

<A NAME="contains(java.lang.String, java.lang.String)"><!-- --></A><H3>
contains</H3>
<PRE>
public static boolean <B>contains</B>(java.lang.String&nbsp;str,
                               java.lang.String&nbsp;substr)</PRE>
<DL>
<DD>Tests if the specified substring is present in the specified string.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>str</CODE> - the enclosing string<DD><CODE>substr</CODE> - the substring
<DT><B>Returns:</B><DD><code>true</code> if the substring is contained in the string,
                        <code>false</code> otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="jxPathContext(java.lang.Object)"><!-- --></A><H3>
jxPathContext</H3>
<PRE>
public static java.lang.Object <B>jxPathContext</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Returns JXPathContext in lenient mode
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the context bean
<DT><B>Returns:</B><DD>JXPathContext instance</DL>
</DD>
</DL>
<HR>

<A NAME="nestedGet(java.lang.Object, java.lang.String)"><!-- --></A><H3>
nestedGet</H3>
<PRE>
public static java.lang.Object <B>nestedGet</B>(java.lang.Object&nbsp;struct,
                                         java.lang.String&nbsp;fetch)</PRE>
<DL>
<DD>Retrieves a object from a series of nested <code>Lists</code> or <code>Map</code>. The
 location of the structure is described by a string of <code>Map</code> keys
 or <code>List</code> indexes, separated by periods.
 <p>
 For example, specifying the string <code>"dog.2"</code> would retrieve
 the object with key <code>"dog"</code> from the supplied <code>Map</code>;
 this object should be a <code>List</code> - the second element of this <code>List</code>
 would be retrieved and returned.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>struct</CODE> - the enclosing <code>List</code> or <code>Map</code><DD><CODE>fetch</CODE> - the string describing the location of the desired object
<DT><B>Returns:</B><DD>the desired object
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if any of the enclosing data structures
                        is neither a <code>Map</code> nor a <code>List</code></DL>
</DD>
</DL>
<HR>

<A NAME="buildList(java.lang.Object)"><!-- --></A><H3>
buildList</H3>
<PRE>
public static java.util.List <B>buildList</B>(java.lang.Object&nbsp;one)</PRE>
<DL>
<DD>Creates a <code>List</code> of one elements. This method is 
 useful because <code>new ArrayList().add()</code> does not return 
 the <code>List</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first element<DD><CODE>two</CODE> - the second element
<DT><B>Returns:</B><DD>the <code>List</code> containing the two elements</DL>
</DD>
</DL>
<HR>

<A NAME="buildList(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
buildList</H3>
<PRE>
public static java.util.List <B>buildList</B>(java.lang.Object&nbsp;one,
                                       java.lang.Object&nbsp;two)</PRE>
<DL>
<DD>Creates a <code>List</code> of two elements.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first element<DD><CODE>two</CODE> - the second element
<DT><B>Returns:</B><DD>the <code>List</code> containing the two elements</DL>
</DD>
</DL>
<HR>

<A NAME="buildList(java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
buildList</H3>
<PRE>
public static java.util.List <B>buildList</B>(java.lang.Object&nbsp;one,
                                       java.lang.Object&nbsp;two,
                                       java.lang.Object&nbsp;three)</PRE>
<DL>
<DD>Creates a <code>List</code> of three elements.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first element<DD><CODE>two</CODE> - the second element<DD><CODE>three</CODE> - the third element
<DT><B>Returns:</B><DD>the <code>List</code> containing the three elements</DL>
</DD>
</DL>
<HR>

<A NAME="buildList(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
buildList</H3>
<PRE>
public static java.util.List <B>buildList</B>(java.lang.Object&nbsp;one,
                                       java.lang.Object&nbsp;two,
                                       java.lang.Object&nbsp;three,
                                       java.lang.Object&nbsp;four)</PRE>
<DL>
<DD>Creates a <code>List</code> of four elements.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>one</CODE> - the first element<DD><CODE>two</CODE> - the second element<DD><CODE>three</CODE> - the third element<DD><CODE>four</CODE> - the fourth element
<DT><B>Returns:</B><DD>the <code>List</code> containing the four elements</DL>
</DD>
</DL>
<HR>

<A NAME="buildMap(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
buildMap</H3>
<PRE>
public static java.util.Map <B>buildMap</B>(java.lang.Object&nbsp;key,
                                     java.lang.Object&nbsp;value)</PRE>
<DL>
<DD>Creates a <code>Map</code> of one key/value pair.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the key<DD><CODE>value</CODE> - the value
<DT><B>Returns:</B><DD>the <code>Map</code> containing the key/value pair</DL>
</DD>
</DL>
<HR>

<A NAME="buildMap(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
buildMap</H3>
<PRE>
public static java.util.Map <B>buildMap</B>(java.lang.Object&nbsp;key,
                                     java.lang.Object&nbsp;value,
                                     java.lang.Object&nbsp;key2,
                                     java.lang.Object&nbsp;value2)</PRE>
<DL>
<DD>Creates a <code>Map</code> of two key/value pairs.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the first key<DD><CODE>value</CODE> - the first value<DD><CODE>key2</CODE> - the second key<DD><CODE>value2</CODE> - the second value
<DT><B>Returns:</B><DD>the <code>Map</code> containing the two key/value pairs</DL>
</DD>
</DL>
<HR>

<A NAME="buildMap(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
buildMap</H3>
<PRE>
public static java.util.Map <B>buildMap</B>(java.lang.Object&nbsp;key,
                                     java.lang.Object&nbsp;value,
                                     java.lang.Object&nbsp;key2,
                                     java.lang.Object&nbsp;value2,
                                     java.lang.Object&nbsp;key3,
                                     java.lang.Object&nbsp;value3)</PRE>
<DL>
<DD>Creates a <code>Map</code> of three key/value pairs.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the first key<DD><CODE>value</CODE> - the first value<DD><CODE>key2</CODE> - the second key<DD><CODE>value2</CODE> - the second value<DD><CODE>key3</CODE> - the third key<DD><CODE>value3</CODE> - the third value
<DT><B>Returns:</B><DD>the <code>Map</code> containing the three key/value pairs</DL>
</DD>
</DL>
<HR>

<A NAME="buildMap(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
buildMap</H3>
<PRE>
public static java.util.Map <B>buildMap</B>(java.lang.Object&nbsp;key,
                                     java.lang.Object&nbsp;value,
                                     java.lang.Object&nbsp;key2,
                                     java.lang.Object&nbsp;value2,
                                     java.lang.Object&nbsp;key3,
                                     java.lang.Object&nbsp;value3,
                                     java.lang.Object&nbsp;key4,
                                     java.lang.Object&nbsp;value4)</PRE>
<DL>
<DD>Creates a <code>Map</code> of four key/value pairs.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the first key<DD><CODE>value</CODE> - the first value<DD><CODE>key2</CODE> - the second key<DD><CODE>value2</CODE> - the second value<DD><CODE>key3</CODE> - the third key<DD><CODE>value3</CODE> - the third value<DD><CODE>key4</CODE> - the fourth key<DD><CODE>value4</CODE> - the fourth value
<DT><B>Returns:</B><DD>the <code>Map</code> containing the four key/value pairs</DL>
</DD>
</DL>
<HR>

<A NAME="buildMap(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
buildMap</H3>
<PRE>
public static java.util.Map <B>buildMap</B>(java.lang.Object&nbsp;key,
                                     java.lang.Object&nbsp;value,
                                     java.lang.Object&nbsp;key2,
                                     java.lang.Object&nbsp;value2,
                                     java.lang.Object&nbsp;key3,
                                     java.lang.Object&nbsp;value3,
                                     java.lang.Object&nbsp;key4,
                                     java.lang.Object&nbsp;value4,
                                     java.lang.Object&nbsp;key5,
                                     java.lang.Object&nbsp;value5)</PRE>
<DL>
<DD>Creates a <code>Map</code> of five key/value pairs.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the first key<DD><CODE>value</CODE> - the first value<DD><CODE>key2</CODE> - the second key<DD><CODE>value2</CODE> - the second value<DD><CODE>key3</CODE> - the third key<DD><CODE>value3</CODE> - the third value<DD><CODE>key4</CODE> - the fourth key<DD><CODE>value4</CODE> - the fourth value<DD><CODE>key5</CODE> - the fifth key<DD><CODE>value5</CODE> - the fifth value
<DT><B>Returns:</B><DD>the <code>Map</code> containing the five key/value pairs</DL>
</DD>
</DL>
<HR>

<A NAME="buildMap(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
buildMap</H3>
<PRE>
public static java.util.Map <B>buildMap</B>(java.lang.Object&nbsp;key,
                                     java.lang.Object&nbsp;value,
                                     java.lang.Object&nbsp;key2,
                                     java.lang.Object&nbsp;value2,
                                     java.lang.Object&nbsp;key3,
                                     java.lang.Object&nbsp;value3,
                                     java.lang.Object&nbsp;key4,
                                     java.lang.Object&nbsp;value4,
                                     java.lang.Object&nbsp;key5,
                                     java.lang.Object&nbsp;value5,
                                     java.lang.Object&nbsp;key6,
                                     java.lang.Object&nbsp;value6)</PRE>
<DL>
<DD>Creates a <code>Map</code> of six key/value pairs.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the first key<DD><CODE>value</CODE> - the first value<DD><CODE>key2</CODE> - the second key<DD><CODE>value2</CODE> - the second value<DD><CODE>key3</CODE> - the third key<DD><CODE>value3</CODE> - the third value<DD><CODE>key4</CODE> - the fourth key<DD><CODE>value4</CODE> - the fourth value<DD><CODE>key5</CODE> - the fifth key<DD><CODE>value5</CODE> - the fifth value<DD><CODE>key6</CODE> - the sixth key<DD><CODE>value6</CODE> - the sixth value
<DT><B>Returns:</B><DD>the <code>Map</code> containing the six key/value pairs</DL>
</DD>
</DL>
<HR>

<A NAME="buildMap(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
buildMap</H3>
<PRE>
public static java.util.Map <B>buildMap</B>(java.lang.Object&nbsp;key,
                                     java.lang.Object&nbsp;value,
                                     java.lang.Object&nbsp;key2,
                                     java.lang.Object&nbsp;value2,
                                     java.lang.Object&nbsp;key3,
                                     java.lang.Object&nbsp;value3,
                                     java.lang.Object&nbsp;key4,
                                     java.lang.Object&nbsp;value4,
                                     java.lang.Object&nbsp;key5,
                                     java.lang.Object&nbsp;value5,
                                     java.lang.Object&nbsp;key6,
                                     java.lang.Object&nbsp;value6,
                                     java.lang.Object&nbsp;key7,
                                     java.lang.Object&nbsp;value7)</PRE>
<DL>
<DD>Creates a <code>Map</code> of six key/value pairs.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - the first key<DD><CODE>value</CODE> - the first value<DD><CODE>key2</CODE> - the second key<DD><CODE>value2</CODE> - the second value<DD><CODE>key3</CODE> - the third key<DD><CODE>value3</CODE> - the third value<DD><CODE>key4</CODE> - the fourth key<DD><CODE>value4</CODE> - the fourth value<DD><CODE>key5</CODE> - the fifth key<DD><CODE>value5</CODE> - the fifth value<DD><CODE>key6</CODE> - the sixth key<DD><CODE>value6</CODE> - the sixth value<DD><CODE>key7</CODE> - the seventh key<DD><CODE>value7</CODE> - the seventh value
<DT><B>Returns:</B><DD>the <code>Map</code> containing the six key/value pairs</DL>
</DD>
</DL>
<HR>

<A NAME="getSingle(java.lang.Object)"><!-- --></A><H3>
getSingle</H3>
<PRE>
public static java.lang.Object <B>getSingle</B>(java.lang.Object&nbsp;toFetchFrom)</PRE>
<DL>
<DD>Retrieves the element of a single element <code>List</code>, or the key
 of a single key/value pair <code>Map</code>. Returns <code>null</code> if the
 <code><i>toFetchFrom</i></code> argument is not a <code>List</code> or 
 <code>Map</code>, or if <code><i>toFetchFrom</i></code> does not contain a 
 single element.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toFetchFrom</CODE> - the source <code>List</code> or <code>Map</code>
<DT><B>Returns:</B><DD>the single element or key</DL>
</DD>
</DL>
<HR>

<A NAME="checkSize(java.lang.Object)"><!-- --></A><H3>
checkSize</H3>
<PRE>
public static int <B>checkSize</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Obtains the size of a <code>Map</code>, <code>List</code> or <code>String</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the <code>Map</code>, <code>List</code> or <code>String</code>
<DT><B>Returns:</B><DD>the size of the <code>Map</code>, <code>List</code> or 
                                        <code>String</code>, as an <code>int</code> or <code>0</code> 
                                        if the object is of another class</DL>
</DD>
</DL>
<HR>

<A NAME="fastDateFormat(java.util.Date)"><!-- --></A><H3>
fastDateFormat</H3>
<PRE>
public static java.lang.String <B>fastDateFormat</B>(java.util.Date&nbsp;date)</PRE>
<DL>
<DD>Returns a <code>String</code> representation of a <code>Date</code> object. 
 This method is faster than using the <code>SimpleDateFormat</code> methods.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>date</CODE> - the date to be formatted
<DT><B>Returns:</B><DD>the formatted date as a <code>String</code></DL>
</DD>
</DL>
<HR>

<A NAME="getStackTrace(java.lang.Throwable)"><!-- --></A><H3>
getStackTrace</H3>
<PRE>
public static java.lang.String <B>getStackTrace</B>(java.lang.Throwable&nbsp;t)</PRE>
<DL>
<DD>Returns the stack trace of a <code>Throwable</code> object as a <code>String</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t</CODE> - the <code>Throwable</code> object
<DT><B>Returns:</B><DD>the stack trace for <code><i>t</i></code> as a <code>String</code></DL>
</DD>
</DL>
<HR>

<A NAME="remapRow(java.util.Map, java.util.Map, boolean)"><!-- --></A><H3>
remapRow</H3>
<PRE>
public static java.util.Map <B>remapRow</B>(java.util.Map&nbsp;row,
                                     java.util.Map&nbsp;remap,
                                     boolean&nbsp;keepNonRemapped)</PRE>
<DL>
<DD>Change the keys used in a <code>Map</code> to a new set of keys. Given an existing 
 <code>Map</code> and a mapping from old keys to new keys, create a new <code>Map</code>
 that uses the new keys.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - the row, a <code>Map</code><DD><CODE>remap</CODE> - the map of original to new column names<DD><CODE>keepNonRemapped</CODE> - <code>boolean</code> indicating whether to keep data under 
                                                        keys that are not remapped
<DT><B>Returns:</B><DD>the row with remapped keys, or the original row, if 
                                                        <code>remap</code> is <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="remapRow(java.util.Map, java.util.Map)"><!-- --></A><H3>
remapRow</H3>
<PRE>
public static java.util.Map <B>remapRow</B>(java.util.Map&nbsp;row,
                                     java.util.Map&nbsp;remap)</PRE>
<DL>
<DD>Change the keys used in a <code>Map</code> to a new set of keys. Given an existing 
 <code>Map</code> and a mapping from old keys to new keys, create a new <code>Map</code> 
 that uses the new keys. Columns from the original row that were not remapped will be 
 retained.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>row</CODE> - the row, a <code>Map</code><DD><CODE>remap</CODE> - the <code>Map</code> of original to new column names
<DT><B>Returns:</B><DD>the row with remapped keys, or the original row, if 
                                        <code><i>remap</i></code> is <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="remapRows(java.util.List, java.util.Map, boolean)"><!-- --></A><H3>
remapRows</H3>
<PRE>
public static java.util.List <B>remapRows</B>(java.util.List&nbsp;rows,
                                       java.util.Map&nbsp;remap,
                                       boolean&nbsp;keepNonRemapped)</PRE>
<DL>
<DD>Remap the keys in a <code>List</code> of <code>Maps</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rows</CODE> - the <code>List</code> of rows<DD><CODE>remap</CODE> - the <code>Map</code> of original to new column names<DD><CODE>keepNonRemapped</CODE> - <code>boolean</code> indicating whether to keep data under 
                                                        keys that are not remapped
<DT><B>Returns:</B><DD>the result set with remapped columns, or the original 
                                                        <code>List</code>, if <code><i>remap</i></code> is <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="remapRows(java.util.List, java.util.Map)"><!-- --></A><H3>
remapRows</H3>
<PRE>
public static java.util.List <B>remapRows</B>(java.util.List&nbsp;rows,
                                       java.util.Map&nbsp;remap)</PRE>
<DL>
<DD>Remap the keys in a <code>List</code> of <code>Maps</code>. Columns from the 
 original row that were not remapped will be retained.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rows</CODE> - the <code>List</code> of rows<DD><CODE>remap</CODE> - the <code>Map</code> of original to new column names
<DT><B>Returns:</B><DD>the result set with remapped columns, or the original 
                                        <code>List</code>, if <code><i>remap</i></code> is <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getProperty(java.util.List, java.lang.Object)"><!-- --></A><H3>
getProperty</H3>
<PRE>
public static java.util.List <B>getProperty</B>(java.util.List&nbsp;rows,
                                         java.lang.Object&nbsp;column)</PRE>
<DL>
<DD>Given a result set, as a <code>List</code> of rows, and a column name, 
 returns the <code>List</code> of values for that column.
 <p>
 The result set is represented as a <code>List</code> of <code>Map</code> objects,
 with each <code>Map</code> representing a row of data. The keys and values in each
 row correspond to the column names and data, respectively.
 <p>
 For rows that do not have a value for the specified column, no value will be present in
 the return list, in other words, an empty object will not be added for that row.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rows</CODE> - the <code>List</code> of rows<DD><CODE>column</CODE> - the column name or key
<DT><B>Returns:</B><DD>the <code>List</code> of values for <code><i>column</i></code></DL>
</DD>
</DL>
<HR>

<A NAME="findAll(java.util.List, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
findAll</H3>
<PRE>
public static java.util.List <B>findAll</B>(java.util.List&nbsp;rows,
                                     java.lang.Object&nbsp;propertyName,
                                     java.lang.Object&nbsp;value)</PRE>
<DL>
<DD>Given a List of Maps, return all Maps that have a certain value for a key.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rows</CODE> - the List of Maps<DD><CODE>propertyName</CODE> - the propertyName (key in the Map)<DD><CODE>value</CODE> - expected value of the propertyName (may be null)
<DT><B>Returns:</B><DD>a List of matching Maps, or an empty list if no matches</DL>
</DD>
</DL>
<HR>

<A NAME="findAll(java.util.List, java.util.Map)"><!-- --></A><H3>
findAll</H3>
<PRE>
public static java.util.List <B>findAll</B>(java.util.List&nbsp;rows,
                                     java.util.Map&nbsp;properties)</PRE>
<DL>
<DD>Given a List of Maps, return all Maps that have common key/value pairs with another Map.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rows</CODE> - the List of Maps<DD><CODE>properties</CODE> - Map of key/value pairs to match.  May not have null values.
<DT><B>Returns:</B><DD>a List of matching Maps, or an empty list if no matches</DL>
</DD>
</DL>
<HR>

<A NAME="toLowerCaseList(java.util.List)"><!-- --></A><H3>
toLowerCaseList</H3>
<PRE>
public static java.util.List <B>toLowerCaseList</B>(java.util.List&nbsp;list)</PRE>
<DL>
<DD>Given a <code>List</code> of strings, returns a new <code>List</code> of lower cased strings.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>list</CODE> - the <code>List</code> of strings
<DT><B>Returns:</B><DD>the <code>List</code> of lower cased strings</DL>
</DD>
</DL>
<HR>

<A NAME="prettyPrint(java.lang.Object)"><!-- --></A><H3>
prettyPrint</H3>
<PRE>
public static java.lang.String <B>prettyPrint</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>Formats information about an <code>Object</code> for viewing or printing as 
 a <code>String</code>.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the <code>Object</code> to be formatted for output
<DT><B>Returns:</B><DD>the information <code>String</code> to be used for the 
                                        <code>Object</code> in viewing or printing</DL>
</DD>
</DL>
<HR>

<A NAME="addToIntInMap(java.util.Map, java.lang.Object, int)"><!-- --></A><H3>
addToIntInMap</H3>
<PRE>
public static void <B>addToIntInMap</B>(java.util.Map&nbsp;map,
                                 java.lang.Object&nbsp;key,
                                 int&nbsp;addition)</PRE>
<DL>
<DD>Add to the value of an Integer instance stored in the map "map" under key "key".
 <p>
 If no Integer is currently stored under "key", creates a new Integer with value 0 before
 adding to it.
 <p>
 This method exists because of the horrific chain of typecasts otherwise necessary to achieve
 this effect.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="incrementIntInMap(java.util.Map, java.lang.Object)"><!-- --></A><H3>
incrementIntInMap</H3>
<PRE>
public static void <B>incrementIntInMap</B>(java.util.Map&nbsp;map,
                                     java.lang.Object&nbsp;key)</PRE>
<DL>
<DD>Add to the value of an Integer instance stored in the map "map" under key "key".
 <p>
 If no Integer is currently stored under "key", creates a new Integer with value 0 before
 adding to it.
 <p>
 This method exists because of the horrific chain of typecasts otherwise necessary to achieve
 this effect.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getIntInMap(java.util.Map, java.lang.Object)"><!-- --></A><H3>
getIntInMap</H3>
<PRE>
public static int <B>getIntInMap</B>(java.util.Map&nbsp;map,
                              java.lang.Object&nbsp;key)</PRE>
<DL>
<DD>Get value of an Integer instance stored in the map "map" under key "key", as the primitive
 type <code>int</code>.
 <p>
 Returns 0 if no Integer is currently stored in the Map.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getterName(java.lang.reflect.Method)"><!-- --></A><H3>
getterName</H3>
<PRE>
public static java.lang.String <B>getterName</B>(java.lang.reflect.Method&nbsp;method)</PRE>
<DL>
<DD>Tests if method is getter and returns property name. Returns <code>null</code>
 if provided method is not getter.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>method</CODE> - <code>Method</code> Getter to extract property name.
<DT><B>Returns:</B><DD><code>String</code> Getter property name or <code>null</code> if provided
      method is not getter.</DL>
</DD>
</DL>
<HR>

<A NAME="getClassFields(java.lang.Class)"><!-- --></A><H3>
getClassFields</H3>
<PRE>
public static java.lang.reflect.Field[] <B>getClassFields</B>(java.lang.Class&nbsp;c)</PRE>
<DL>
<DD>Returns array of all fields declared in specified class and it's supper classes.
 Array contains fields with all modifiers. Returns empty array if provided
 parameter is <code>null</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - <code>Class</code> to be inspected.
<DT><B>Returns:</B><DD><code>Field[]</code> Array of class fields.</DL>
</DD>
</DL>
<HR>

<A NAME="getClassMethods(java.lang.Class)"><!-- --></A><H3>
getClassMethods</H3>
<PRE>
public static java.lang.reflect.Method[] <B>getClassMethods</B>(java.lang.Class&nbsp;c)</PRE>
<DL>
<DD>Returns array of all methods declared in specified class and it's supper classes.
 Array contains methods with all modifiers as well as overriden methods from
 super classes. Returns empty array if provided parameter is <code>null</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - <code>Class</code> to be inspected.
<DT><B>Returns:</B><DD><code>Method[]</code> Array of class methods.</DL>
</DD>
</DL>
<HR>

<A NAME="getPropertyType(java.lang.Class, java.lang.String)"><!-- --></A><H3>
getPropertyType</H3>
<PRE>
public static java.lang.Class <B>getPropertyType</B>(java.lang.Class&nbsp;c,
                                              java.lang.String&nbsp;propertyName)
                                       throws java.beans.IntrospectionException</PRE>
<DL>
<DD>Returns type of specified property in provided class. Property name can be composed
 of sub-properties separated by dot for example:<ul>
 <li>property1 - type of property1 will be returned</li>
 <li>property1.subproperty - type of sub-property will be returned</li></ul>
 Property will be looked up in specified order:<ol>
 <li>Among fields declared in specified class</li>
 <li>Among methods declared in specified class</li>
 <li>Among fields declared in all supper classes</li>
 <li>Among methods declared in all supper classes</li></ol>
 Only getter methods are tested: method has no parameters and it's name starts with
 either "get" or "is".<br/>
 Throws <code>NullPointerException</code> if either of parameters is null.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - <code>Class</code> to be inspected.<DD><CODE>propertyName</CODE> - <code>String</code> Name of property.
<DT><B>Returns:</B><DD><code>Class</code> Type of property.
<DT><B>Throws:</B>
<DD><CODE>java.beans.IntrospectionException</CODE> - when specified class has no such property.</DL>
</DD>
</DL>
<HR>

<A NAME="getCachedClass(java.lang.String)"><!-- --></A><H3>
getCachedClass</H3>
<PRE>
public static java.lang.Class <B>getCachedClass</B>(java.lang.String&nbsp;className)</PRE>
<DL>
<DD>Returns loaded <code>Class</code> object for specified name.
 Cached class is returned if exists otherwise class object is loaded and cached.
 Returns <code>null</code> if class can not be loaded (not in class path).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>className</CODE> - <code>String</code> qualified class name to load.
<DT><B>Returns:</B><DD><code>Class</code> object of <code>null</code> if class can not be loaded (not in class path).</DL>
</DD>
</DL>
<HR>

<A NAME="getRealClass(java.lang.Object)"><!-- --></A><H3>
getRealClass</H3>
<PRE>
public static java.lang.Class <B>getRealClass</B>(java.lang.Object&nbsp;bean)</PRE>
<DL>
<DD>Checks if provided bean is a proxy and extracts real class.
 If bean is not a proxy class then its getClass() is returned.
 Current implementation checks only for Hibernate proxies.
 Real class is extracted via
 <code>realClass = (Class) ((HibernateProxy) bean).getHibernateLazyInitializer().getPersistentClass();</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bean</CODE> - <code>Object</code>
<DT><B>Returns:</B><DD><code>Class</code></DL>
</DD>
</DL>
<HR>

<A NAME="getProperties(java.lang.Object)"><!-- --></A><H3>
getProperties</H3>
<PRE>
public static java.util.Map <B>getProperties</B>(java.lang.Object&nbsp;bean)
                                   throws java.lang.Exception</PRE>
<DL>
<DD>Gets the properties for a JavaBean and returns them as a <code>Map</code>.<p/>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bean</CODE> - the JavaBean object
<DT><B>Returns:</B><DD>the JavaBean properties as a <code>Map</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getPropertyDescriptors(java.lang.Object)"><!-- --></A><H3>
getPropertyDescriptors</H3>
<PRE>
public static java.util.Map <B>getPropertyDescriptors</B>(java.lang.Object&nbsp;bean)
                                            throws java.lang.Exception</PRE>
<DL>
<DD>Gets the property descriptors for a JavaBean and returns them as a <code>Map</code>.<p/>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bean</CODE> - the JavaBean object
<DT><B>Returns:</B><DD>the JavaBean property descriptors as a <code>Map</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getPropertyDescriptors(java.lang.Class)"><!-- --></A><H3>
getPropertyDescriptors</H3>
<PRE>
public static java.util.Map <B>getPropertyDescriptors</B>(java.lang.Class&nbsp;beanClass)
                                            throws java.lang.Exception</PRE>
<DL>
<DD>Gets the properties for a JavaBean class through introspection and returns them as a <code>Map</code>.<p/>
 Removes properties added by byte-code instrumentation:<ul>
 <li><code>interceptFieldCallback</code> property is removed if class implements
 <code>net.sf.cglib.transform.impl.InterceptFieldEnabled</code> interface;</li>
 <li><code>fieldHandler</code> property is removed if class implements
 <code>org.hibernate.bytecode.javassist.FieldHandled</code> interface;</li>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>beanClass</CODE> - the JavaBean class
<DT><B>Returns:</B><DD>the JavaBean class's property descriptors as a <code>Map</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setProperties(java.util.Map, java.lang.Object)"><!-- --></A><H3>
setProperties</H3>
<PRE>
public static java.lang.Object <B>setProperties</B>(java.util.Map&nbsp;propertyMap,
                                             java.lang.Object&nbsp;bean)
                                      throws java.lang.Exception</PRE>
<DL>
<DD>As the three-argument version of this method, but passes a null dataSource
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>propertyMap</CODE> - a <code>Map</code> providing the key-value pairs<DD><CODE>bean</CODE> - the JavaBean object
<DT><B>Returns:</B><DD>the JavaBean properties as a <code>Map</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if a value provided in the <code>Map</code> 
                      cannot be converted to an appropriate type
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setProperties(java.util.Map, java.lang.Object, com.isomorphic.datasource.DataSource)"><!-- --></A><H3>
setProperties</H3>
<PRE>
public static java.lang.Object <B>setProperties</B>(java.util.Map&nbsp;propertyMap,
                                             java.lang.Object&nbsp;bean,
                                             <A HREF="../../../com/isomorphic/datasource/DataSource.html" title="class in com.isomorphic.datasource">DataSource</A>&nbsp;ds)
                                      throws java.lang.Exception</PRE>
<DL>
<DD>Sets the properties for a JavaBean provided as key-value pairs in a <code>Map</code>.
 This method performs automatic type detection and conversion where possible.  Conversion
 is done via standard bean semantics.  Additionally, some standard conversions are
 performed automatically - for example inbound java.util.Date object will be
 auto-converted to java.sql.Date or java.sql.Timestamp.
 <p>
 Keys for which conversion fails or for which there are no corresponding Bean properties
 are ignored. 
 <p>
 For properties that have primitive value on the target bean (eg properties of
 <code>int</code> type), generally, the static "valueOf(String)" method for the primitive type
 (eg Boolean.valueOf(String)) will be invoked on the result of "toString()" for the Object
 being assigned to the primitive property.
 <p>
 As special cases the null string ("") and the <code>null</code> value will become 0 when
 assigned to numeric primitive types (which cannot be null).
 <p>
 If the null string is assigned to a non-primitive numeric type (eg Long), the property will
 be assigned <code>null</code>.
 <p>
 If the target bean property is an enum, this method attempts to set an appropriate
 value by use of the enum translate strategy set by calling setEnumTranslateStrategy() on
 the dataSource, if one is provided.  See <A HREF="../../../com/isomorphic/datasource/DataSource.html#setEnumTranslateStrategy(java.lang.String)"><CODE>DataSource.setEnumTranslateStrategy(String)</CODE></A>.
 If there is no DataSource, or it cannot set a value by cleanly using the 
 enumTranslateStrategy, it will attempt to infer a value by considering the incoming value first as 
 a String to match against the enumerated type's value names, and failing that as an 
 integer to match against the enumerated type's values as an ordinal value.  If that 
 fails, it sets the target bean property to null. 
 <p>
 Otherwise, if the type accepted by a setter method on the target bean cannot accept the type
 of the value in the propertyMap, this method will attempt type conversion by looking for a
 constructor on the setter method type that accepts instances of the value's type.
 <p>
 Also, if a Map value is found in the values of the passed in propertyMap, and the recipient
 field on the bean is not a Map, this method will treat the target field as a bean,
 attempting to create the bean via newInstance() and populating it via a recursive call
 to this method.  In other words, this method will auto-create and populate inner beans.
 <P>
 Similarly if a Collection is found in the propertyMap, it will be applied to a target
 field of Collection type.  If the target field is of an abstract Collection type,
 the default types used are:
 <ul>
 <li>Map -> LinkedMap
 <li>List or Collection -> ArrayList
 <li>Set -> HashSet
 <li>Queue -> LinkedList
 </ul>
 Java Generics declarations will be automatically used to determine the type of each
 member of any collection.  For example, a bean property declared of type List<SomeBean>
 will be populated automatically with instances of SomeBean.
 <p>
 A DataSource can be optionally passed as the third argument and can modify some of the
 above behaviors, including choice of concrete type when populating bean properties that
 declare only an abstract type or base type - See <A HREF="../../../com/isomorphic/datasource/DataSource.html#setProperties(java.util.Map, java.lang.Object)"><CODE>DataSource.setProperties(Map, Object)</CODE></A> for details.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>propertyMap</CODE> - a <code>Map</code> providing the key-value pairs<DD><CODE>bean</CODE> - the JavaBean object<DD><CODE>dataSource</CODE> - a context DataSource, if applicable.  Can be null
<DT><B>Returns:</B><DD>the JavaBean object
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if a value provided in the <code>Map</code> 
                                                cannot be converted to an appropriate type
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setProperties(java.util.Map, java.lang.Object, com.isomorphic.datasource.DataSource, com.isomorphic.datasource.DSRequest)"><!-- --></A><H3>
setProperties</H3>
<PRE>
public static java.lang.Object <B>setProperties</B>(java.util.Map&nbsp;propertyMap,
                                             java.lang.Object&nbsp;bean,
                                             <A HREF="../../../com/isomorphic/datasource/DataSource.html" title="class in com.isomorphic.datasource">DataSource</A>&nbsp;ds,
                                             <A HREF="../../../com/isomorphic/datasource/DSRequest.html" title="class in com.isomorphic.datasource">DSRequest</A>&nbsp;dsRequest)
                                      throws java.lang.Exception</PRE>
<DL>
<DD>This version of setProperties accepts a DSRequest for use as context by the conversion
 process.  In particular, the DSRequest is passed to the getDataSource() method of a
 <A HREF="../../../com/isomorphic/datasource/DynamicDSGenerator.html" title="interface in com.isomorphic.datasource"><CODE>DynamicDSGenerator</CODE></A>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>propertyMap</CODE> - a <code>Map</code> providing the key-value pairs<DD><CODE>bean</CODE> - the JavaBean object<DD><CODE>dataSource</CODE> - a context DataSource, if applicable<DD><CODE>dsRequest</CODE> - a context DSRequest, if applicable
<DT><B>Returns:</B><DD>the JavaBean object
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if a value provided in the <code>Map</code> 
                      cannot be converted to an appropriate type
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="registerTransformer(java.lang.Class, com.isomorphic.util.DataTools.Transformer)"><!-- --></A><H3>
registerTransformer</H3>
<PRE>
public static void <B>registerTransformer</B>(java.lang.Class&nbsp;targetType,
                                       <A HREF="../../../com/isomorphic/util/DataTools.Transformer.html" title="interface in com.isomorphic.util">DataTools.Transformer</A>&nbsp;transformer)</PRE>
<DL>
<DD>Register a Transformer.  The Transformer interface specifies a single transform() method.
 The transform() method must be capable of creating an object of type targetType from 
 the input Object.  In a simple case, this could typically be done by making use of 
 Object.toString.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>targetType</CODE> - the Class that this Transformer is capable of transforming to<DD><CODE>transformer</CODE> - the Transformer object itself</DL>
</DD>
</DL>
<HR>

<A NAME="castValue(java.lang.Object, java.lang.Class, com.isomorphic.datasource.DataSource)"><!-- --></A><H3>
castValue</H3>
<PRE>
public static java.lang.Object <B>castValue</B>(java.lang.Object&nbsp;value,
                                         java.lang.Class&nbsp;targetType,
                                         <A HREF="../../../com/isomorphic/datasource/DataSource.html" title="class in com.isomorphic.datasource">DataSource</A>&nbsp;ds)</PRE>
<DL>
<DD>Converts specified <code>value</code> to <code>targetType</code>.
 <br/>
 Implemented conversion rules:<ul>

 <li>Returns <code>null</code> if passed value is <code>null</code></li>

 <li>If passed value can be cast to <code>targetType</code> then same value returned</li>

 <li>For primitive types returns appropriate object for example:if
 <code>targetType</code> is <code>Long.TYPE</code> method returns <code>Long</code></li>

 <li>If <code>targetType</code> is <code>Boolean</code> and passed value is instance of
 <code>Number</code> then 0 converted to <code>false</code>; any other number converted
 to <code>true</code></li>
 <li>If <code>targetType</code> is <code>Boolean</code> and passed value is instance of
 <code>Character</code> then 'T', 't', 'Y' and 'y' converted to <code>true</code>; any
 other character converted to <code>false</code></li>
 <li>If <code>targetType</code> is <code>Boolean</code> and passed value is instance of
 <code>String</code> then "true", "t", "yes" and "y" (ignoring case) converted to
 <code>true</code>; any other string converted to <code>false</code></li>

 <li>If <code>targetType</code> is <code>Byte</code> and passed value is instance of
 <code>Boolean</code> then <code>false</code> converted to 0;
 <code>true</code> converted to 1</li>
 <li>If <code>targetType</code> is <code>Byte</code> and passed value is instance of
 <code>Number</code> then value may be rounded and/or truncated</li>
 <li>If <code>targetType</code> is <code>Byte</code> and passed value is instance of
 <code>String</code> then value is parsed with <code>Byte.valueOf()</code></li>

 <li>If <code>targetType</code> is <code>Short</code> and passed value is instance of
 <code>Boolean</code> then <code>false</code> converted to 0;
 <code>true</code> converted to 1</li>
 <li>If <code>targetType</code> is <code>Short</code> and passed value is instance of
 <code>Number</code> then value may be rounded and/or truncated</li>
 <li>If <code>targetType</code> is <code>Short</code> and passed value is instance of
 <code>String</code> then value is parsed with <code>Short.valueOf()</code></li>

 <li>If <code>targetType</code> is <code>Integer</code> and passed value is instance of
 <code>Boolean</code> then <code>false</code> converted to 0;
 <code>true</code> converted to 1</li>
 <li>If <code>targetType</code> is <code>Integer</code> and passed value is instance of
 <code>Number</code> then value may be rounded and/or truncated</li>
 <li>If <code>targetType</code> is <code>Integer</code> and passed value is instance of
 <code>Character</code> then caracter value is returned</li>
 <li>If <code>targetType</code> is <code>Integer</code> and passed value is instance of
 <code>String</code> then value is parsed with <code>Integer.valueOf()</code></li>

 <li>If <code>targetType</code> is <code>Long</code> and passed value is instance of
 <code>Boolean</code> then <code>false</code> converted to 0;
 <code>true</code> converted to 1</li>
 <li>If <code>targetType</code> is <code>Long</code> and passed value is instance of
 <code>Number</code> then value may be rounded and/or truncated</li>
 <li>If <code>targetType</code> is <code>Long</code> and passed value is instance of
 <code>Character</code> then caracter value is returned</li>
 <li>If <code>targetType</code> is <code>Long</code> and passed value is instance of
 <code>String</code> then value is parsed with <code>Long.valueOf()</code></li>
 <li>If <code>targetType</code> is <code>Long</code> and passed value is instance of
 <code>Date</code> then <code>Date.getTime()</code> returned</li>

 <li>If <code>targetType</code> is <code>Float</code> and passed value is instance of
 <code>Boolean</code> then <code>false</code> converted to 0;
 <code>true</code> converted to 1</li>
 <li>If <code>targetType</code> is <code>Float</code> and passed value is instance of
 <code>Number</code> then value may be rounded and/or truncated</li>
 <li>If <code>targetType</code> is <code>Float</code> and passed value is instance of
 <code>Character</code> then caracter value is returned</li>
 <li>If <code>targetType</code> is <code>Float</code> and passed value is instance of
 <code>String</code> then value is parsed with <code>Float.valueOf()</code></li>
 <li>If <code>targetType</code> is <code>Float</code> and passed value is instance of
 <code>Date</code> then <code>Date.getTime()</code> returned</li>

 <li>If <code>targetType</code> is <code>Double</code> and passed value is instance of
 <code>Boolean</code> then <code>false</code> converted to 0;
 <code>true</code> converted to 1</li>
 <li>If <code>targetType</code> is <code>Double</code> and passed value is instance of
 <code>Number</code> then value may be rounded</li>
 <li>If <code>targetType</code> is <code>Double</code> and passed value is instance of
 <code>Character</code> then caracter value is returned</li>
 <li>If <code>targetType</code> is <code>Double</code> and passed value is instance of
 <code>String</code> then value is parsed with <code>Double.valueOf()</code></li>
 <li>If <code>targetType</code> is <code>Double</code> and passed value is instance of
 <code>Date</code> then <code>Date.getTime()</code> returned</li>

 <li>If <code>targetType</code> is <code>Character</code> and passed value is instance of
 <code>Boolean</code> then <code>false</code> converted to 'f';
 <code>true</code> converted to 't'</li>
 <li>If <code>targetType</code> is <code>Character</code> and passed value is instance of
 <code>Number</code> then character for value code returned (value may be rounded and/or
 truncated)</li>
 <li>If <code>targetType</code> is <code>Character</code> and passed value is instance of
 <code>String</code> then returns first string charater; <code>(char) 0</code> returned
 for empty string</li>

 <li>If <code>targetType</code> is <code>String</code> then <code>value.toString()</code>
 returned</li>

 <li>If <code>targetType</code> is <code>BigInteger</code> and passed value is instance of
 <code>Boolean</code> then <code>false</code> converted to <code>BigInteger.ZERO</code>;
 <code>true</code> converted to <code>BigInteger.ONE</code></li>
 <li>If <code>targetType</code> is <code>BigInteger</code> and passed value is instance of
 <code>Number</code> then value may be rounded</li>
 <li>If <code>targetType</code> is <code>BigInteger</code> and passed value is instance of
 <code>Character</code> then caracter value is returned</li>
 <li>If <code>targetType</code> is <code>BigInteger</code> and passed value is instance of
 <code>String</code> then value is parsed</li>
 <li>If <code>targetType</code> is <code>BigInteger</code> and passed value is instance of
 <code>Date</code> then <code>Date.getTime()</code> returned</li>

 <li>If <code>targetType</code> is <code>BigDecimal</code> and passed value is instance of
 <code>Boolean</code> then <code>false</code> converted to <code>BigDecimal.ZERO</code>;
 <code>true</code> converted to <code>BigDecimal.ONE</code></li>
 <li>If <code>targetType</code> is <code>BigDecimal</code> and passed value is instance of
 <code>Number</code> then value converted to <code>BigDecimal</code></li>
 <li>If <code>targetType</code> is <code>BigDecimal</code> and passed value is instance of
 <code>Character</code> then caracter value is returned</li>
 <li>If <code>targetType</code> is <code>BigDecimal</code> and passed value is instance of
 <code>String</code> then value is parsed</li>
 <li>If <code>targetType</code> is <code>BigDecimal</code> and passed value is instance of
 <code>Date</code> then <code>Date.getTime()</code> returned</li>

 <li>If <code>targetType</code> is <code>java.util.Date</code> and passed value is
 instance of <code>Number</code> then <code>java.util.Date</code> created with value as
 miliseconds (value may be rounded and/or truncated)</li>
 <li>If <code>targetType</code> is <code>java.util.Date</code> and passed value is
 instance of <code>String</code> then value is parsed with
 <code>DateFormat.getDateTimeInstance()</code></li>

 <li>If <code>targetType</code> is <code>java.sql.Date</code> and passed value is
 instance of <code>Number</code> then <code>java.sql.Date</code> created with value as
 miliseconds (value may be rounded and/or truncated)</li>
 <li>If <code>targetType</code> is <code>java.sql.Date</code> and passed value is
 instance of <code>String</code> then value is parsed with
 <code>DateFormat.getDateInstance()</code></li>
 <li>If <code>targetType</code> is <code>java.sql.Date</code> and passed value is
 instance of <code>java.util.Date</code> then value is converted</li>
 <li>If <code>targetType</code> is <code>java.sql.Date</code> and passed value is
 instance of <code>java.sql.Time</code> then value is converted</li>
 <li>If <code>targetType</code> is <code>java.sql.Date</code> and passed value is
 instance of <code>java.sql.Timestamp</code> then value is converted</li>

 <li>If <code>targetType</code> is <code>java.sql.Time</code> and passed value is
 instance of <code>Number</code> then <code>java.sql.Time</code> created with value as
 miliseconds (value may be rounded and/or truncated)</li>
 <li>If <code>targetType</code> is <code>java.sql.Time</code> and passed value is
 instance of <code>String</code> then value is parsed with
 <code>DateFormat.getTimeInstance()</code></li>
 <li>If <code>targetType</code> is <code>java.sql.Time</code> and passed value is
 instance of <code>java.util.Date</code> then value is converted</li>
 <li>If <code>targetType</code> is <code>java.sql.Time</code> and passed value is
 instance of <code>java.sql.Date</code> then value is converted</li>
 <li>If <code>targetType</code> is <code>java.sql.Time</code> and passed value is
 instance of <code>java.sql.Timestamp</code> then value is converted</li>

 <li>If <code>targetType</code> is <code>java.sql.Timestamp</code> and passed value is
 instance of <code>Number</code> then <code>java.sql.Timestamp</code> created with value
 as miliseconds (value may be rounded and/or truncated)</li>
 <li>If <code>targetType</code> is <code>java.sql.Timestamp</code> and passed value is
 instance of <code>String</code> then value is parsed with
 <code>DateFormat.getDateTimeInstance()</code></li>
 <li>If <code>targetType</code> is <code>java.sql.Timestamp</code> and passed value is
 instance of <code>java.util.Date</code> then value is converted</li>
 <li>If <code>targetType</code> is <code>java.sql.Timestamp</code> and passed value is
 instance of <code>java.sql.Date</code> then value is converted</li>
 <li>If <code>targetType</code> is <code>java.sql.Timestamp</code> and passed value is
 instance of <code>java.sql.Time</code> then value is converted</li>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - <code>Object</code> value to be converted.<DD><CODE>targetType</CODE> - <code>Class</code> conversion target type.<DD><CODE>ds</CODE> - <code>DataSource</code> initiating conversion.
<DT><B>Returns:</B><DD><code>Object</code> converted value.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ClassCastException</CODE> - if value can not be converted or parsing exception occurs.</DL>
</DD>
</DL>
<HR>

<A NAME="isTextType(java.lang.Class)"><!-- --></A><H3>
isTextType</H3>
<PRE>
public static boolean <B>isTextType</B>(java.lang.Class&nbsp;clazz)</PRE>
<DL>
<DD>Returns <code>true</code> if provided class is either assignable to <code>Character</code> or
 assignable to <code>String</code> or represents primitive <code>char</code> type.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>clazz</CODE> - <code>Class</code> for testing.
<DT><B>Returns:</B><DD><code>boolean</code> <code>true</code> if specified class represents class for text;
      <code>false</code> - for all other classes.</DL>
</DD>
</DL>
<HR>

<A NAME="isNumberType(java.lang.Class)"><!-- --></A><H3>
isNumberType</H3>
<PRE>
public static boolean <B>isNumberType</B>(java.lang.Class&nbsp;clazz)</PRE>
<DL>
<DD>Returns <code>true</code> if provided class is either assignable to <code>Number</code> or
 represents one of primitive number types <code>byte, short, int, long, float, double</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>clazz</CODE> - <code>Class</code> for testing.
<DT><B>Returns:</B><DD><code>boolean</code> <code>true</code> if specified class represents class for numbers;
      <code>false</code> - for all other classes.</DL>
</DD>
</DL>
<HR>

<A NAME="recursiveFileDelete(java.io.File)"><!-- --></A><H3>
recursiveFileDelete</H3>
<PRE>
public static boolean <B>recursiveFileDelete</B>(java.io.File&nbsp;file)</PRE>
<DL>
<DD>Recursively deletes a directory.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>file</CODE> - file or directory to delete
<DT><B>Returns:</B><DD>true if successful, false otherwise
                                                cannot be converted to an appropriate type</DL>
</DD>
</DL>
<HR>

<A NAME="md5(java.lang.String)"><!-- --></A><H3>
md5</H3>
<PRE>
public static java.lang.String <B>md5</B>(java.lang.String&nbsp;plaintext)
                            throws java.lang.Exception</PRE>
<DL>
<DD>Returns the hash of the passed-in string, encrypted using the MD5 algorithm
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>plaintext</CODE> - the text to encrypt
<DT><B>Returns:</B><DD>the encrypted (MD5) hash of the supplied plaintext
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="sha(java.lang.String)"><!-- --></A><H3>
sha</H3>
<PRE>
public static java.lang.String <B>sha</B>(java.lang.String&nbsp;plaintext)
                            throws java.lang.Exception</PRE>
<DL>
<DD>Returns the hash of the passed-in string, encrypted using the SHA-1 algorithm
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>plaintext</CODE> - the text to encrypt
<DT><B>Returns:</B><DD>the encrypted (SHA) hash of the supplied plaintext
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="hashValue(java.lang.String)"><!-- --></A><H3>
hashValue</H3>
<PRE>
public static java.lang.String <B>hashValue</B>(java.lang.String&nbsp;plaintext)
                                  throws java.lang.Exception</PRE>
<DL>
<DD>Returns the hash of the passed-in string, encrypted using the MD5 algorithm
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>plaintext</CODE> - the text to encrypt
<DT><B>Returns:</B><DD>the encrypted (MD5) hash of the supplied plaintext
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="hashValue(java.lang.String, java.lang.String)"><!-- --></A><H3>
hashValue</H3>
<PRE>
public static java.lang.String <B>hashValue</B>(java.lang.String&nbsp;plaintext,
                                         java.lang.String&nbsp;algorithm)
                                  throws java.lang.Exception</PRE>
<DL>
<DD>Returns the hash of the passed-in string, encrypted using the specified algorithm
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>plaintext</CODE> - the text to encrypt<DD><CODE>algorithm</CODE> - the encryption algorithm to use.  Search the client-side 
                          documentation for "HashAlgorithm" for details.
<DT><B>Returns:</B><DD>the encrypted hash of the supplied plaintext
<DT><B>Throws:</B>
<DD><CODE>java.lang.Exception</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="formatDate(java.lang.String, java.util.Date)"><!-- --></A><H3>
formatDate</H3>
<PRE>
public static java.lang.String <B>formatDate</B>(java.lang.String&nbsp;format,
                                          java.util.Date&nbsp;date)</PRE>
<DL>
<DD>Returns the parameter date formatted according to the parameter format string.  This 
 method is trivial - it just creates a SimpleDateFormat object and calls its format()
 method - but it is useful for formatting dates in Velocity expressions
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>format</CODE> - A valid SimpleDateFormat format string<DD><CODE>date</CODE> - The date to format
<DT><B>Returns:</B><DD>The date formatted according to the format string</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../com/isomorphic/util/ErrorMessage.html" title="class in com.isomorphic.util"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?com/isomorphic/util/DataTools.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="DataTools.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
